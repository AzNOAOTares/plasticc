# -*- coding: UTF-8 -*-
"""
ANTARES Object class specification

"""

from __future__ import absolute_import
from __future__ import unicode_literals
import warnings
import numpy as np
from .features.periodic import PeriodicMixin
from .features.gp import GPMixin
from .features.spline import SplineMixin
from .features.base import BaseMixin

__all__=['LAobject']

class LAobject(PeriodicMixin, GPMixin, SplineMixin, BaseMixin):
    """
    ANTARES object - locus aggregated alert lightcurve and feature encapsulator

    :py:func:`antares.model.helper.MakeTouchstoneObject` creates a
    :py:class:`ANTARES_object` instance from an event alert.

    TODO: rename ``MakeTouchstoneObject`` something more useful

    Parameters
    ----------
    locusId : str or int
        the ANTARES locus aggegated alert ID
    objectId : str or int
        The unique identifier for each Object - it's name from the source survey e.g. diaObjectId
    time : array-like
        The mid-point of the observation - e.g. midPointTai from DIASource
    flux : array-like
        The calibrated flux - e.g. totFlux of each DIASource
    fluxErr : array-like
        The calibrated flux uncertainty - e.g. totFluxErr of each DIASource
    obsId : array-like
        The list of IDS  corresponding to the observations - e.g. diaSourceId
    passband : array-like
        The passband of each observation
    zeropoint : float or array-like
        The zeropoint of each observation - used to convert to Pogson magnitudes if possible
    per : bool
        Boolean flag indicating if this object is considered a periodic variable or not
    best_period : float or None
        If `per`, then the best-estimate of the period of this object
    header : None or dict
        A header entry as a dictionary of values that should be preserved during processing

    Notes
    -----
        Follows the DPDD as of 20170810:
        https://docushare.lsstcorp.org/docushare/dsweb/Get/LSE-163/

        ``time``, ``flux``, ``fluxErr``, ``obsID``, ``passband`` must be 1-D
        arrays with the same shape, and have at least one element
    """
    def __init__(self, locusId, objectId,\
                    time, flux, fluxErr, obsId, passband,zeropoint,\
                    per=False, best_period=None,\
                    header=None, mag=True):

        # object name or ID - an alert ID generated by ANTARES or pre-supplied
        # note that if ANTARES is generating its own IDs, then we need someway
        # to store a DIAObject ID

        self.objectId = objectId
        self.locusId  = locusId

        self.time      = np.array(time).astype('f')
        self.flux      = np.array(flux).astype('f')
        self.fluxErr   = np.array(fluxErr).astype('f')
        self.obsId     = np.array(obsId)
        self.passband  = passband
        zeropoint      = np.atleast_1d(zeropoint)

        # check that the arrays have the same shape
        assert self.time.ndim  == 1
        _tshape = self.time.shape
        assert _tshape == self.flux.shape
        assert _tshape == self.fluxErr.shape
        assert _tshape == self.obsId.shape
        assert _tshape == self.passband.shape

        if len(zeropoint) == 1:
            zeropoint = np.repeat(zeropoint, _tshape[0])
        self.zeropoint = zeropoint

        # implement a quick bad values filter here
        mask = np.logical_and((self.fluxErr > 1E-6), np.isfinite(self.fluxErr))
        mask = np.logical_and(mask, np.isfinite(self.flux))
        mask = np.logical_and(mask, self.fluxErr < self.flux)
        mask = np.logical_and(mask, np.isfinite(self.zeropoint))

        # these cuts are temporary, because while we're calling it flux, it's really still mags
        if mag:
            mask = np.logical_and(mask, self.flux > 0.)
            mask = np.logical_and(mask, self.flux <= 99.)
            mask = np.logical_and(mask, self.fluxErr <= 9.)
            # this cut looks the same as the other one, but the first is to get rid of missing values represented by 9.999
            # the second is to get rid of measurements with large errors
            mask = np.logical_and(mask, self.fluxErr <= 0.5)

        self.time      = self.time[mask]
        self.flux      = self.flux[mask]
        self.fluxErr   = self.fluxErr[mask]
        self.obsId     = self.obsId[mask]
        self.passband  = self.passband[mask]
        self.zeropoint = self.zeropoint[mask]

        self.nobs = len(self.time)
        if self.nobs == 0:
            message = 'Object {} with locus ID {} has no good observations.'.format(objectId, locusId)
            raise ValueError(message)

        self.filters    = list(set(self.passband))

        self.per        = per
        if self.per:
            self.best_period   = best_period
            self.lcPeriodic    = np.nan
            self.lcNonPeriodic = None
        else:
            self.best_period   = None
            self.lcPeriodic    = None
            self.lcNonPeriodic = np.nan
        self.header = header
